#!/usr/bin/env python3
#
# ccon-oci(1) - OCI compatibility wrapper around ccon.
# Copyright (C) 2015,2016 W. Trevor King <wking@tremily.us>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Requires Python 3.3+ for os.pipe2 [1].
#
# [1]: https://docs.python.org/3/library/os.html#os.pipe2

"""opencontainers/specs runtime wrapper for ccon
"""

import argparse
import base64
import datetime
import inspect
import json
import os
import resource
import shutil
import subprocess
import sys
import textwrap
import unicodedata
import uuid


OCI_VERSIONS = [
    '0.1.0',
    '0.2.0',
    '0.3.0',
    '0.4.0',
    '0.5.0',
    '1.0.0-rc1',
]

_MOUNT_FLAGS = {  # from mount(8) and mount(2)
    'bind': 'MS_BIND',
    'dirsync': 'MS_DIRSYNC',
    'iversion': 'MS_I_VERSION',
    'lazytime': 'MS_LAZYTIME',
    'mand': 'MS_MANDLOCK',
    # MS_MOVE
    'noatime': 'MS_NOATIME',
    'nodev': 'MS_NODEV',
    'nodiratime': 'MS_NODIRATIME',
    'noexec': 'MS_NOEXEC',
    'nosuid': 'MS_NOSUID',
    # MS_PRIVATE
    'ro': 'MS_RDONLY',
    # MS_REC
    'relatime': 'MS_RELATIME',
    'remount': 'MS_REMOUNT',
    # MS_SHARED
    'silent': 'MS_SILENT',
    # MS_SLAVE
    'strictatime': 'MS_STRICTATIME',
    'sync': 'MS_SYNCHRONOUS',
    # MS_UNBINDABLE
}

_INVERSE_MOUNT_FLAGS = {  # from mount(8)
    'noiversion': 'iversion',
    'nolazytime': 'lazytime',
    'nomand': 'mand',
    'atime': 'noatime',
    'dev': 'nodev',
    'diratime': 'nodiratime',
    'exec': 'noexec',
    'suid': 'nosuid',
    'rw': 'ro',
    'norelatime': 'relatime',
    'loud': 'silent',
    'nostrictatime': 'strictatime',
    'async': 'sync',
}


def version():
    """Print version information and exit.
    """
    os.execlp('ccon', '--version')


def _get_version(config, pop=False):
    version = None
    for key in ['ociVersion', 'version']:
        if key in config:
            if pop:
                version = config.pop(key)
            else:
                version = config[key]
            break
    if version is None:
        raise ValueError('no version found in config.json')
    if version not in OCI_VERSIONS:
        raise NotImplementedError(
            'unsupported OCI-spec version: {}'.format(version))
    if version in ['0.1.0', '0.2.0', '0.3.0'] and key not in 'version':
        raise ValueError(
            'OCI versions before 0.4.0 should store the version information'
            "in 'version', not in {!r}"
            .format(key)
        )
    if version in ['0.4.0', '0.5.0', '1.0.0-rc1'] and key not in 'ociVersion':
        raise ValueError(
            'OCI versions 0.4.0 and later should store the version information'
            "in 'ociVersion', not in {!r}"
            .format(key)
        )
    return version


def _convert_namespaces(namespaces):
    ns = {}
    for namespace in namespaces:
        name = namespace.pop('type')
        if name == 'network':
            name = 'net'
        ns[name] = {}
        if 'path' in namespace:
            ns[name]['path'] = namespace.pop('path')
        if namespace:
            raise NotImplementedError(
                'unparsed runtime.json namespace fields: {}'
                .format(namespace))
    return ns


def _mount_flags(options):
    flags = []
    for option in list(options):
        if option in _MOUNT_FLAGS:
            flags.append(_MOUNT_FLAGS[option])
            options.remove(option)
        if option in _INVERSE_MOUNT_FLAGS:
            inverse = _INVERSE_MOUNT_FLAGS[option]
            options.remove(option)
            if inverse in flags:
                flags.remove(inverse)
    return (flags, ','.join(options))


def _convert_split_mount(mount_point, mount_sources, root_path=None):
    """Convert the config/runtime mounts from OCI 0.2.0 and earlier.
    """
    mounts = []
    name = mount_point.pop('name')
    mount_source = mount_sources[name].copy()
    options = mount_source.pop('options', [])
    flags, data = _mount_flags(options=options)
    target = mount_point.pop('path')
    if root_path:
        target = os.path.join(root_path, target.lstrip(os.path.sep))
    mount = {
        'type': mount_source.pop('type'),
        'source': mount_source.pop('source'),
        'target': target,
    }
    if flags:
        mount['flags'] = flags
    if data:
        mount['data'] = data
    mounts.append(mount)
    if mount_point:
        raise NotImplementedError(
            'unparsed config.json mount fields: {}'.format(mount_point))
    if mount_source:
        raise NotImplementedError(
            'unparsed runtime.json mount fields: {}'.format(mount_source))
    return mounts


def _convert_mount(mount, root_path=None):
    """Convert the config mounts from OCI 0.3.0 and later.
    """
    mounts = []
    options = mount.pop('options', [])
    flags, data = _mount_flags(options=options)
    target = mount.pop('destination')
    if root_path:
        target = os.path.join(root_path, target.lstrip(os.path.sep))
    _mount = {
        'type': mount.pop('type'),
        'source': mount.pop('source'),
        'target': target,
    }
    if flags:
        _mount['flags'] = flags
    if data:
        _mount['data'] = data
    mounts.append(_mount)
    if mount:
        raise NotImplementedError(
            'unparsed config.json mount fields: {}'.format(mount))
    return mounts


def _convert_root(basedir, root):
    rt = os.path.join(basedir, root['path'])
    dev = os.path.join(rt, 'dev')
    proc = os.path.join(rt, 'proc')
    sys = os.path.join(rt, 'sys')
    run = os.path.join(rt, 'run')
    tmp = os.path.join(rt, 'tmp')
    for path in [dev, proc, sys, run, tmp]:
        os.makedirs(path, exist_ok=True)
    remount_flags = [
        'MS_REMOUNT',
        'MS_BIND'
    ]
    if root.get('readonly'):
        remount_flags.append('MS_RDONLY')
    return [
        {
            'source': rt,
            'target': rt,
            'flags': [
                'MS_BIND'
            ]
        },
        {
            'source': '/dev',
            'target': dev,
            'flags': [
                'MS_BIND',
                'MS_REC'
            ]
        },
        {
            'target': proc,
            'type': 'proc'
        },
        {
            'source': '/sys',
            'target': sys,
            'flags': [
                'MS_BIND',
                'MS_REC'
            ]
        },
        {
            'source': rt,
            'type': 'pivot-root'
        },
        {
            'target': '/',
            'flags': remount_flags,
        },
        {
            'target': '/run',
            'type': 'tmpfs'
        },
        {
            'target': '/tmp',
            'type': 'tmpfs'
        }
    ]


def _convert_hook(version, hook, state=None, read_pid=False):
    if state is None:
        state = {}
    h = {
        'args': hook.pop('args', [hook['path']]),
    }
    if hook['path'] != h['args'][0]:
        h['path'] = hook['path']
    if 'env' in hook:
        h['env'] = hook.pop('env')
    args = [
        sys.argv[0],
        'hook',
        '--state',
        json.dumps(state),
        '--hook',
        json.dumps(h),
    ]
    if 'timeout' in hook:
        if version in ['0.1.0', '0.2.0', '0.3.0', '0.4.0']:
            raise ValueError(
                'timeout was added to hooks in version 0.5.0')
        timeout = hook.pop('timeout')
        args = [
            'timeout',
            '--signal=KILL',
            str(timeout),
        ] + args
    if read_pid:
        args.append('--read-pid')
    return {
        'args': args,
    }


def convert_config(basedir, config, runtime, state):
    version = _get_version(config=config, pop=True)
    if version not in OCI_VERSIONS:
        raise NotImplementedError(
            'unsupported OCI-spec version: {}'.format(version))
    c = {
        'version': '0.4.0',
    }
    platform = config.pop('platform', None)
    _os = platform.pop('os', None)
    if _os != 'linux':
        raise NotImplementedError(
            'ccon only supports linux, not {}'.format(os))
    # If platform.arch is incompatible, ccon will crash
    if version in ['0.1.0', '0.2.0']:
        namespaces = runtime.get('linux', {}).pop('namespaces', [])
    else:
        namespaces = config.get('linux', {}).pop('namespaces', [])
    if namespaces:
        c['namespaces'] = _convert_namespaces(namespaces=namespaces)
    mounts = []
    root = config.pop('root')
    root_path = root['path']
    mount_points = config.pop('mounts', [])
    if version in ['0.1.0', '0.2.0']:
        mount_sources = runtime.pop('mounts', {})
        for mount_point in mount_points:
            mounts.extend(_convert_split_mount(
                mount_point=mount_point, mount_sources=mount_sources,
                root_path=root_path))
    else:
        for mount_point in mount_points:
            mounts.extend(_convert_mount(
                mount=mount_point, root_path=root_path))
    if root:
        root_mounts = _convert_root(basedir=basedir, root=root)
        mounts.insert(0, root_mounts[0])  # remount rootfs first
        mounts.extend(root_mounts[1:])
    if mounts:
        if 'mount' not in c.get('namespaces', {}):
            raise ValueError('cannot set root or mounts without a mount namespace')
        c['namespaces']['mount']['mounts'] = mounts
    for map_type in ['uid', 'gid']:
        field = '{}Mappings'.format(map_type)
        mapping = config.get('linux', {}).pop(field, None)
        if mapping:
            if 'user' not in c.get('namespaces', {}):
                raise ValueError(
                    "cannot set config.json's linux.{} without a user "
                    'namespace'
                    .format(field))
            c['namespaces']['user'][field] = mapping
    rlimits = None
    process = config.pop('process', None)
    if process:
        c['process'] = {}
        for field in [
                'args', 'capabilities', 'cwd', 'env', 'terminal', 'user']:
            if field in process:
                if (field == 'capabilities' and
                        version in ['0.1.0', '0.2.0', '0.3.0']):
                    raise ValueError(
                        'capabilities was moved to process in version 0.4.0')
                c['process'][field] = process.pop(field)
        user = c['process'].get('user', None)
        if user:
            uid = os.geteuid()
            if 'user' not in c.get('namespaces', {}) and uid != 0:
                raise ValueError(
                    "must be root or in a user namespace to set config.json's "
                    'process.user')
            if uid != 0:
                c['namespaces']['user']['setgroups'] = False
        if version in ['0.1.0', '0.2.0']:
            rlimits = runtime.get('linux', {}).pop('rlimits', None)
        elif version == '0.3.0':
            rlimits = config.get('linux', {}).pop('rlimits', None)
        else:
            rlimits = process.pop('rlimits', None)
        if process:
            raise NotImplementedError(
                'unparsed config.json process fields: {}'
                .format(process))
        if version in ['0.1.0', '0.2.0', '0.3.0']:
            capabilities = config.get('linux', {}).pop('capabilities', None)
            if capabilities:
                c['process']['capabilities'] = capabilities
    if version in ['0.1.0', '0.2.0']:
        hooks = runtime.pop('hooks', None)
    else:
        hooks = config.pop('hooks', None)
    if hooks:
        pre_start = hooks.pop('prestart', None)
        if pre_start:
            c['hooks'] = {
                'pre-start': [
                    _convert_hook(
                        version=version, hook=h, state=state, read_pid=True)
                    for h in pre_start],
            }
        post_stop = hooks.pop('poststop', None)
        if post_stop:
            if 'hooks' not in c:
                c['hooks'] = {}
            c['hooks']['post-stop'] = [
                    _convert_hook(version=version, hook=h, state=state)
                    for h in post_stop]
        if hooks:
            raise NotImplementedError(
                'unparsed hooks: {}'.format(hooks))
    if 'hooks' not in c:
        c['hooks'] = {}
    if 'pre-start' not in c['hooks']:
        c['hooks']['pre-start'] = []
    if 'post-stop' not in c['hooks']:
        c['hooks']['post-stop'] = []
    if rlimits:
        c['hooks']['pre-start'].append({
            'args': [sys.argv[0], 'rlimits', json.dumps(rlimits)],
        })
    hostname = config.pop('hostname', None)
    if hostname:
        c['hooks']['pre-start'].append({
            'args': [sys.argv[0], 'hostname', hostname],
        })
    c['hooks']['pre-start'].append({
        'args': [sys.argv[0], 'event', '--register', 'created', state['id']],
    })
    c['hooks']['post-stop'].extend([
        {'args': [sys.argv[0], 'event', '--register', 'stopped', state['id']]},
        {'args': [sys.argv[0], 'delete', state['id']]},
    ])
    if 'linux' in config and not config['linux']:
        config.pop('linux')  # remove empty dictionary
    if runtime and 'linux' in runtime and not runtime['linux']:
        runtime.pop('linux')  # remove empty dictionary
    if config:
        raise NotImplementedError(
            'unparsed config.json fields: {}'.format(config))
    if runtime:
        raise NotImplementedError(
            'unparsed runtime.json fields: {}'.format(runtime))
    return c


def _get_state(version, bundle='.', container_id=None, config=None):
    if container_id is None:
        container_id = uuid.uuid4().hex
    state = {
        'id': container_id,
    }
    if version in ['0.1.0', '0.2.0', '0.3.0']:
        state['version'] = version
    else:
        state['ociVersion'] = version
    bundle = os.path.abspath(bundle)
    if version == '0.1.0':
        state['root'] = bundle
    else:
        state['bundlePath'] = bundle
    if version == '1.0.0-rc1' and 'annotations' in config:
        state['annotations'] = config['annotations']
    return state


def _load_config(bundle='.', id=None):
    """Load OCI configuration and convert to ccon's format.
    """
    with open(os.path.join(bundle, 'config.json'), 'r') as f:
        config = json.load(f)
    version = _get_version(config=config)
    if version in ['0.1.0', '0.2.0']:
        with open(os.path.join(bundle, 'runtime.json'), 'r') as f:
            runtime = json.load(f)
    else:
        runtime = None
    state = _get_state(
        version=version, bundle=bundle, container_id=id, config=config)
    return {
        'config': convert_config(
            basedir=bundle, config=config, runtime=runtime, state=state),
        'state': state,
    }


def _container_dir(container_id):
    id_nfc = unicodedata.normalize('NFC', container_id)
    id_utf8 = id_nfc.encode('UTF-8')
    id_base64 = base64.b64encode(id_utf8, altchars=b'-_')
    tmp_dir = os.environ.get('TMPDIR', '/tmp')
    return os.path.join(tmp_dir, 'ccon-oci', id_base64.decode('UTF-8'))


def _socket_path(container_id):
    return os.path.join(_container_dir(container_id=container_id), 'sock')


def create(bundle='.', id=None, verbose=False):
    """Create a container from a bundle directory.
    """
    args = ['ccon']
    if verbose:
        args.append('--verbose')
    config_state = _load_config(bundle=bundle, id=id)
    config = config_state['config']
    state = config_state['state']
    socket = _socket_path(container_id=state['id'])
    socket_dir = os.path.dirname(socket)
    os.makedirs(socket_dir, exist_ok=True)
    args.extend(['--socket', socket])
    # os.pipe opens with O_CLOEXEC since Python 3.4
    read, write = os.pipe2(0)
    os.write(write, json.dumps(config).encode('UTF-8'))
    os.close(write)
    args.extend(['--config', '/proc/self/fd/{}'.format(read)])
    os.execvp(args[0], args)


def start(id, verbose=False):
    """Start the user-specified code.
    """
    socket = _socket_path(container_id=id)
    args = ['ccon-cli', '--socket', socket, '--config-string', '']
    if verbose:
        args.append('--verbose')
    subprocess.check_call(args)
    event(id=id, register='started')


def _failed_to_remove(func, path, exc_info):
    sys.stderr.write('failed to remove {!r}\n'.format(path))


def delete(id):
    """Helper for releasing persistent container resources.
    """
    sys.stdin.close()
    container_dir = _container_dir(container_id=id)
    shutil.rmtree(container_dir, onerror=_failed_to_remove)


def config(bundle='.', id=None):
    """Convert an OCI config to a ccon config.
    """
    config_state = _load_config(bundle=bundle, id=id)
    config = config_state['config']
    state = config_state['state']
    json.dump(
        config, sys.stdout, indent=2, separators=(',', ': '), sort_keys=True)
    sys.stdout.write('\n')


def hook(state=None, hook=None, read_pid=False):
    """Helper for passing OCI-spec state JSON to hooks.
    """
    state = json.loads(state)
    hook = json.loads(hook)
    stdin_fileno = sys.stdin.fileno()
    if read_pid:
        state['pid'] = int(sys.stdin.read())
    env = {}
    for e in hook['env']:
        key, value = e.split('=', 1)
        env[key] = value
    # os.pipe opens with O_CLOEXEC since Python 3.4
    read, write = os.pipe2(0)
    os.write(write, json.dumps(state).encode('UTF-8'))
    os.close(write)
    os.dup2(read, stdin_fileno)
    os.close(read)
    os.execvpe(hook['args'][0], hook['args'], env)


def event(id, register=None, monitor=False, event=None, historic=False):
    """Helper for registering container-status events.
    """
    stdin_fileno = sys.stdin.fileno()
    sys.stdin.close()
    event_dir = os.path.join(_container_dir(container_id=id), 'event')
    if register:
        event = {
            'type': register,
            'id': id,
            'timestamp': datetime.datetime.utcnow().isoformat() + 'Z'
        }
        # os.pipe opens with O_CLOEXEC since Python 3.4
        read, write = os.pipe2(0)
        os.write(write, json.dumps(event).encode('UTF-8'))
        os.write(write, '\n'.encode('UTF-8'))
        os.close(write)
        os.dup2(read, stdin_fileno)
        os.close(read)
        args = ['inotify-pub', event_dir, register]
    else:  # subscribe
        args = ['inotify-sub']
        if monitor:
            args.append('--monitor')
        if event:
            args.extend(['--event', event])
        if historic:
            args.append('--historic')
        args.append(event_dir)
    os.execvp(args[0], args)


def hostname(hostname):
    """Helper for setting the container hostname.
    """
    pid = int(sys.stdin.read())
    sys.stdin.close()
    config = {
        'version': '0.2.0',
        'process': {
            'args': ['hostname', hostname],
            'host': True,
        },
        'namespaces': {
            'user': {
                'path': '/proc/{pid}/ns/user'.format(pid=pid),
            },
            'uts': {
                'path': '/proc/{pid}/ns/uts'.format(pid=pid),
            },
        },
    }
    # os.pipe opens with O_CLOEXEC since Python 3.4
    read, write = os.pipe2(0)
    os.write(write, json.dumps(config).encode('UTF-8'))
    os.close(write)
    args = ['ccon', '--config', '/proc/self/fd/{}'.format(read)]
    os.execvp(args[0], args)


def rlimits(rlimits):
    """Helper for setting container resource limits.
    """
    pid = int(sys.stdin.read())
    sys.stdin.close()
    limits = json.loads(rlimits)
    for limit in limits:
        rsrc = getattr(resource, limit['type'])
        resource.prlimit(pid, rsrc, (limit['soft'], limit['hard']))


def main():
    parser = argparse.ArgumentParser(
        description=__doc__.strip(),
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument(
        '-V', '--verbose', action='store_true',
        help='enable ccon debugging messages on stderr')
    commands = parser.add_subparsers(
        title='commands',
        description=(
            'For help on a particular command, run: '
            "'%(prog)s ... <command> --help'."))
    for command, func in [
            ('version', version),
            ('create', create),
            ('start', start),
            ('config', config),
            ('hook', hook),
            ('delete', delete),
            ('event', event),
            ('hostname', hostname),
            ('rlimits', rlimits),
            ]:
        doc = textwrap.dedent(func.__doc__).strip().replace('%', '%%')
        subparser = commands.add_parser(
            command,
            help=doc.splitlines()[0],
            description=doc,
            formatter_class=argparse.RawDescriptionHelpFormatter)
        subparser.set_defaults(func=func)
        if command in ['create', 'config']:
            subparser.add_argument(
                '--id', metavar='ID',
                help='Set the container ID for the new container.')
            subparser.add_argument(
                '--bundle', metavar='PATH', default='.',
                help=(
                    'Override the path to the bundle directory (defaults to '
                    'the current working directory).'))
        if command == 'start':
            subparser.add_argument(
                'id', metavar='ID',
                help='Set the container ID to start.')
        if command == 'delete':
            subparser.add_argument(
                'id', metavar='ID',
                help='Set the container ID to delete.')
        if command == 'hook':
            subparser.add_argument(
                '--state', metavar='JSON', required=True,
                help='State JSON (except for the PID) to pass to the hook.')
            subparser.add_argument(
                '--read-pid', action='store_true',
                help='Read the PID from stdin and add it to the state.')
            subparser.add_argument(
                '--hook', metavar='JSON', required=True,
                help='Ccon hook JSON for the user-specified hook.')
        if command == 'event':
            subparser.add_argument(
                'id', metavar='ID',
                help='Set the container ID to connect to.')
            subparser.add_argument(
                '--register', metavar='EVENT',
                help='Register a container-status event (for internal use).')
            subparser.add_argument(
                '-m', '--monitor', action='store_true',
                help=(
                    'Instead of exiting after receiving a single event, '
                    'execute indefinitely.  The default behavior is to exit '
                    'after the first event occurs.'
                ))
            subparser.add_argument(
                '-e', '--event', metavar='EVENT',
                help=(
                    'Listen for specific events only.  If ommitted, all '
                    'events are listened for.'
                ))
            subparser.add_argument(
                '-H', '--historic', action='store_true',
                help=(
                    'Replay historic events.  If ommitted, only new events '
                    'are output.'
                ))
        if command == 'hostname':
            subparser.add_argument(
                'hostname', metavar='HOSTNAME',
                help='Hostname to set.')
        if command == 'rlimits':
            subparser.add_argument(
                'rlimits', metavar='RLIMITS',
                help='Resource limits to set (JSON).')

    args = parser.parse_args()

    if not getattr(args, 'func', None):
        parser.print_usage()
        sys.exit(1)

    if args.func == help:
        arg_names = ['command']
    else:
        (arg_names, varargs, varkw) = inspect.getargs(args.func.__code__)
    kwargs = {key: getattr(args, key) for key in arg_names if key in args}
    args.func(**kwargs)


if __name__ == '__main__':
    main()
